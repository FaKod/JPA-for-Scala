h1. The Idea

Based on 
* "this idea":http://blog.fakod.eu/?p=557
* "JDBCluster":http://jdbcluster.sourceforge.net and
* "JSR 317: JavaTM Persistence 2.0":http://jcp.org/en/jsr/detail?id=317 (JPA 2.0)

The JPA Extension should support
* external query strings (in a separate XML file) 
* type safe query parameter through special Filter Classes (-> "JDBCluster:CCFilter":http://fakod.eu/wiki/index.php?title=JDBCluster#Query_Support_by_CCFilter)
* "Acegi":http://www.acegisecurity.org/ integration
* Domain value check (-> "JDBCluster: Domains":http://fakod.eu/wiki/index.php?title=JDBCluster#Domains_for_Attributes) using "Bean Validation":http://www.jcp.org/en/jsr/detail?id=303
* all this provided as Scala library

h1. Entity Manager and Entity Manager Factory

The framework suports custom EntityManagerFactory implementations. To simplify usage two Traits can be used.

_SimpleEntityManagerFactory_ provides a non JNDI environment EM factory. Method _getPersistenceUnitName_ has to be implemented to provide the persistence unit name as defined in persistence.xml.

_ThreadLocalEntityManager_ provides one Entity Manager instance per Thread.

Example:

<pre>
class MyClass extends Something with SimpleEntityManagerFactory with ThreadLocalEntityManager {
 def getPersistenceUnitName = "mip"
}
</pre>

h1. Queries and Transactions

h2. define query strings

A XML file collects all the used HQL statements. 
Current Scala persistence implementations are trying to provide type safe SQL/HQL statements as classes and objects. I don't think that this is the best way.

* SQL/HQL syntax is quite complex. IMHO it will not be possible to rewrite the whole functionality (especially taking into account SQL enhancements like PostGIS or db vendor dialects)
* I have learned that it can make sense to change a SQL/JPQL statement in production (add redundancy tables etc.)
* Nevertheless, type safe SQL/JPQL parameter are important
* JPA and JPA2.0 are widely adopted and used (field proven implementations) java standards

h2. JPAExtension.xml example file

<pre>
<filter>
  <!-- simple JPQL query with one parameter-->
  <query id="UserFromName" jpql="select u from User u where u.name like ?1"/>

  <!-- simple native SQL query with two parameter-->
  <query id="DistancePointFromTextToLocID" jpql="select distance(pointfromtext(?1),lp.geometry) from location_point as lp where lp.loc_id=?2"/>

  <!-- JPQL query with one parameter and filer class. Maps N to name -->
  <query id="FindObjectItemFromNameWithFilter" alias="oi" jpql="oi.nameTxt like :N">
    <filterClass class="com.jpaextension.test.NameFilter">
      <binding var="N" attribute="name"/>
    </filterClass>
  </query>

  <!-- JPQL query with relation fetch statements and query annotations -->
  <query id="fetchFilter" alias="c" annotation="myAnno1 myAnno2">
	<fetch property="owner"/>
	<fetch property="sparePart" joinType="left"/>
  </query>	
</filter>
</pre>

h2. Execute Query with Filter Class

The above defined query with the ID _FindObjectItemFromNameWithFilter_ can use the filter _NameFilter_ for holding the binding attribute _name_. _name_ will be used to replace _N_.
Since the query can return more than one result _forQueryResults_ can be used to iterate over the result-set.

<pre>
val filter: NameFilter = newFilterInstance(QueryId("FindObjectItemFromNameWithFilter"))
filter.name = "%Test%"

var i = 0
forQueryResults {
  oi: ObjectItem =>
    i = i + 1
} withQuery (filter)
i must_== 10
</pre>

h2. fetch statement for preload relations

The fetch tag allows the preload of (lazy) relations. In case of _fetchFilter_ the relations _owner_ and _sparePart_ are fetched while loading the data from DB.

h2. annotations for the executed query

For the design of persistence layers it is useful to provide some query annotations (as a list of simple text). _myAnno1_ is an example. Annotations can be retrieved using a filer object.

h2. Query Snippets

Sometimes several queries contain a common part. This can be put as a constant snippet to JPAExtension.xml.

h2. example using a query with one expected result and no transaction

<pre>
withNoTrx {
  val user: User = oneResultQuery withQuery (QueryId("UserFromName"), "Lionel")
  user
}
</pre>

h2. iterating over query results without transaction

<pre>
withNoTrx {
 forQueryResults {
  u: User =>
   userIDs.add(u.getId)
   userNames.add(u.getName)
 } withQuery (QueryId("UserFromName"), "%" + name + "%")
}
</pre>

h2. find one entity, remove it and commit the transaction

<pre>
withTrxAndCommit {
 findAndApply(id ) {
   u:User => remove(u)
 }
}
</pre>

h1. execute a native SQL query and expect one result

<pre>
withTrxAndCommit {
 oneResultQueryAndApply {
  d: Double =>
   eStatRet.setDistance(d)
  } withNativeQuery (QueryId("DistancePointFromTextToLocID"), postGISPoint, user.getUsersLocation.getId)
}
</pre>

h2. REST examples

These examples are using a JAX-RS standard implementation from SUN called Jersey.
_exceptionWrapper_ and _checkAccessRights_ are used to generate WebApplicationExceptions and to check the access rights based on HTTP-session credentials.

<pre>
 @PUT
 @Path("UserInfo/{uid}")
 def updateUserInfo(@PathParam("uid") uid: String, eui: EUserInfo): EUserInfo = {
   exceptionWrapper {
     checkAccessRights {
       withTrxAndCommit {
         findAndApply(id(uid) ) {
           u:User =>
             val userInfoId = u.getUserInfo.getId
             val newUserInfo: UserInfo = eui.getUserInfo
             newUserInfo.setId(userInfoId)
             merge[UserInfo](newUserInfo)
         }
       }
     }
   }
 }
</pre>

h1. Filter Usage Examples

h2. Defining Filter (query) Object and Query

The XML snippet defines that _com.jpaextension.test.data.SomeFilter_ will contain the binding parameter _NT_ and _CID_ for query _MyOIQuery_.

<pre>
<query id="MyOIQuery" alias="oi" jpql="oi.creatorId=:CID and oi.nameTxt=:NT">
    <filterClass class="com.jpaextension.test.data.SomeFilter">
        <binding var="CID" attribute="creatorId"/>
        <binding var="NT" attribute="nameTxt"/>
    </filterClass>
</query>
</pre>

The following code creates a Filter Object _myFilter_, sets the binding parameter and executes the query.

<pre>
withNoTrx {
	val myFilter: SomeFilter = newFilterInstance(QueryId("MyOIQuery"))

	myFilter.creatorId = BigInteger.valueOf(815)
	myFilter.nameTxt = "Test1"

	val result = createFilterQuery[ObjectItem](myFilter).getResultList
	result.size must_== 1
}
</pre>