h1. The Idea

Based on 
* "this idea":http://blog.fakod.eu/?p=557
* "JDBCluster":http://jdbcluster.sourceforge.net and
* "JSR 317: JavaTM Persistence 2.0":http://jcp.org/en/jsr/detail?id=317 (JPA 2.0)

The JPA Extension should support
* external query strings (in a separate XML file) 
* type safe query parameter through special Filter Classes (-> "JDBCluster:CCFilter":http://fakod.eu/wiki/index.php?title=JDBCluster#Query_Support_by_CCFilter)
* "Acegi":http://www.acegisecurity.org/ integration
* Domain value check (-> "JDBCluster: Domains":http://fakod.eu/wiki/index.php?title=JDBCluster#Domains_for_Attributes) using "Bean Validation":http://www.jcp.org/en/jsr/detail?id=303
* all this provided as Scala library

h1. Queries and Transactions

h2. define query strings

A XML file collects all the used HQL statements. 
Current Scala persistence implementations are trying to provide type safe SQL/HQL statements as classes and objects. I don't think that this is the best way.
* SQL/HQL syntax is quite complex. IMHO it will not be possible to rewrite the whole functionality
* I have learned that it can make sense to change a SQL/HQL statement in production (add redundancy etc.)
* type safe binding parameter are more important

<pre>
<filter>
  <query id="UserFromName" jpql="select u from User u where u.name like ?1"/>
  <query id="DistancePointFromTextToLocID" jpql="select distance(pointfromtext(?1),lp.geometry) from location_point as lp where lp.loc_id=?2"/>
  <query id="FindObjectItemFromNameWithFilter" alias="oi" jpql="oi.nameTxt like :N">
    <filterClass class="com.jpaextension.test.NameFilter">
      <binding var="N" attribute="name"/>
    </filterClass>
  </query>
</filter>
</pre>

h2. Execute Query with Filter Class

<pre>
val filter: NameFilter = newFilterInstance(QueryId("FindObjectItemFromNameWithFilter"), classOf[ObjectItem])
filter.name = "%Test%"

var i = 0
forQueryResults {
  oi: ObjectItem =>
    i = i + 1
} withQuery (filter)
i must_== 1
</pre>

h2. example using a query with one expected result and no transaction

<pre>
withNoTrx {
  val user: User = oneResultQuery withQuery (QueryId("UserFromName"), "Lionel")
  user
}
</pre>

h2. iterating over query results

<pre>
withNoTrx {
 forQueryResults {
  u: User =>
   userIDs.add(u.getId)
   userNames.add(u.getName)
 } withQuery (QueryId("UserFromName"), "%" + name + "%")
}
</pre>

h2. find one entity, remove it and commit the transaction

<pre>
withTrxAndCommit {
 findAndApply(classOf[User], id ) {
  u => remove(u)
 }
}
</pre>

h1. execute a native SQL query and expect one result

<pre>
withTrxAndCommit {
 oneResultQueryAndApply {
  d: Double =>
   eStatRet.setDistance(d)
  } withNativeQuery (QueryId("DistancePointFromTextToLocID"), postGISPoint, user.getUsersLocation.getId)
}
</pre>

h2. REST examples

These examples are using a JAX-RS standard implementation from SUN called Jersey.
_exceptionWrapper_ and _checkAccessRights_ are used to generate WebApplicationExceptions and to check the access rights based on HTTP-session credentials.

<pre>
 @PUT
 @Path("UserInfo/{uid}")
 def updateUserInfo(@PathParam("uid") uid: String, eui: EUserInfo): EUserInfo = {
   exceptionWrapper {
     checkAccessRights {
       withTrxAndCommit {
         findAndApply(classOf[User], id(uid) ) {
           u =>
             val userInfoId = u.getUserInfo.getId
             val newUserInfo: UserInfo = eui.getUserInfo
             newUserInfo.setId(userInfoId)
             merge[UserInfo](newUserInfo)
         }
       }
     }
   }
 }
</pre>

h1. Filter Usage Examples

h2. Defining Filter (query) Object and Query

The XML snippet defines that _com.jpaextension.test.data.SomeFilter_ will contain the binding parameter _NT_ and _CID_ for query _MyOIQuery_.

<pre>
<query id="MyOIQuery" alias="oi" jpql="oi.creatorId=:CID and oi.nameTxt=:NT">
    <filterClass class="com.jpaextension.test.data.SomeFilter">
        <binding var="CID" attribute="creatorId"/>
        <binding var="NT" attribute="nameTxt"/>
    </filterClass>
</query>
</pre>

The following code creates a Filter Object _myFilter_, sets the binding parameter and executes the query.

<pre>
withNoTrx {
	val myFilter: SomeFilter = newFilterInstance(QueryId("MyOIQuery"), classOf[ObjectItem])

	myFilter.creatorId = BigInteger.valueOf(815)
	myFilter.nameTxt = "Test1"

	val result = createFilterQuery(myFilter).getResultList
	result.size must_== 1
}
</pre>